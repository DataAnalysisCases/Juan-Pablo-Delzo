#Recepcion de datos:
import os
import csv
import pandas as pd
import numpy as np
from sklearn.decomposition import PCA
pca = PCA(n_components=250)
localdir = "C:\Users\juand\Documents\Analisis de Datos\Python\Aplicaciones\p2.7\Ejercicio"
filename = "trainingData.csv"
filepath = os.path.join(localdir, filename)
trainingdata = pd.read_csv(filepath, header= 0, index_col= False)
trainingdata = trainingdata.values
trainingx = trainingdata[:,:520]
pca.fit(trainingx)
trainingx = pca.transform(trainingx)
trainingy = trainingdata[:, 521]
filename = "validationData.csv"
filepath = os.path.join(localdir, filename)
validationdata = pd.read_csv(filepath, header= 0, index_col= False)
validationdata = validationdata.values
validationx = validationdata[:,:520]
validationx = pca.transform(validationx)
validationy = validationdata[:,521]


#LONGITUDE:
print("LONGITUDE:")
#Interaction k:
from sklearn.neighbors import KNeighborsClassifier
from sklearn.cross_validation import cross_val_score
from sklearn.cross_validation import KFold
crossvalidation = KFold( n= trainingx.shape[0], n_folds= 10, shuffle = True, random_state= 100)
valoresk= np.arange(1,17,step= 2)
errores = []
print 'Results k:'
for k in valoresk:
    knn = KNeighborsClassifier(n_neighbors= k)
    scores = cross_val_score(knn, trainingx,trainingy, scoring= 'mean_squared_error',cv=crossvalidation)  
    mean_error = np.mean(np.abs(scores))
    errores =  errores + [mean_error]
    print 'for k= %2i error is %.2f m' % (k,mean_error)
print 'Optimal k= %2i' % (valoresk[errores.index(min(errores))])
#Plot:
import matplotlib.pyplot as plt
plt.plot(valoresk, errores,'bD--')
plt.grid()
plt.xlabel('Number of Neighbors')
plt.ylabel('Mean squared error (meters)')
plt.title('Cross-Validation curve in Longitude')
plt.show()

# Evaluating K=1:
KKN = KNeighborsClassifier(n_neighbors=1)
KKN.fit(trainingx,trainingy)
X = KKN.predict(validationx)
x = validationy
print 'Prediction with K=1'
print 'Average Longitude: %.2f m' % (np.mean(np.abs(X- x)))

#LATITUDE:
trainingy = trainingdata[:, 522]
validationy = validationdata[:,522]
print("LATITUDE:")

#Interaction k:
from sklearn.neighbors import KNeighborsClassifier
from sklearn.cross_validation import cross_val_score
from sklearn.cross_validation import KFold
crossvalidation = KFold( n= trainingx.shape[0], n_folds= 10, shuffle = True, random_state= 100)
valoresk= np.arange(1,17,step= 2)
errores = []
print 'Results k:'
for k in valoresk:
    knn = KNeighborsClassifier(n_neighbors= k)
    scores = cross_val_score(knn, trainingx,trainingy, scoring= 'mean_squared_error',cv=crossvalidation)  
    mean_error = np.mean(np.abs(scores))
    errores =  errores + [mean_error]
    print 'for k= %2i error is %.4f m' % (k,mean_error)
print 'Optimal k= %2i' % (valoresk[errores.index(min(errores))])
#Plot:
import matplotlib.pyplot as plt
plt.plot(valoresk, errores,'bD--')
plt.grid()
plt.xlabel('Number of Neighbors')
plt.ylabel('Mean squared error (meters)')
plt.title('Cross-Validation curve in Latitude')
plt.show()

# Evaluating K=1:
KKN = KNeighborsClassifier(n_neighbors=1)
KKN.fit(trainingx,trainingy)
Y = KKN.predict(validationx)
y = validationy
print 'Prediction with K=1'
print 'Average Latitude: %.2f m' % (np.mean(np.abs(Y- y)))

#Evaluating the average distance error:
import math
print 'HORIZONTAL DISTANCE:'
print 'Average distance error: % .2f m' % (np.mean(np.sqrt(((X-x)**2)+((Y-y)**2))))

# Error: 8.49 m


